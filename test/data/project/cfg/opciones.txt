teniendo este yaml en un fichero

kind: BasicProject
apiVersion: v1
metadata:
  name: Nombre_de_proyecto
  files_8_3: True
spec:
  step1:
    componente1:
      - mx0001
      - mx0002
    componente2:
      - mx0001
      - mx0002
    componente3:
      - mx0001
  step2:
    componente4:
      - mx0001
      - mx0002
    componente5:
      - mx0001
      - mx0002
    componente6:
      - mx0001  

quiero en pipeline declarativo de jenkins, leer los steps de uno en uno, dentro de cada step leer todos los componetes que tenga, y lanzar en paralelo tantos jobs como mx tenga cada componente, teniendo en cuenta que los steps pueden ser variables, es decir puedo tener uno, como 2 como 33... etc.

teniendo este yaml en un fichero

##############################################################################################

kind: BasicProject
apiVersion: v1
metadata:
  name: Nombre_de_proyecto
  files_8_3: True
spec:
  nexus:
    pepe: sadfasdf
    juan: asdfasdf
  resources:
    - componente4
    - componente5

OBTENEMOS LOS RECURSOS DE UN COMPONENTE


def obtenerResourcesDesdeYAML(String rutaArchivoYAML) {
    def yamlContent = readYaml file: rutaArchivoYAML
    return yamlContent.spec.resources
}

pipeline {
    agent any

    stages {
        stage('Obtener Resources') {
            steps {
                script {
                    def resources = obtenerResourcesDesdeYAML('ruta/al/tu/archivo.yaml')
                    echo "Resources: ${resources.join(', ')}"
                    // Puedes usar la lista 'resources' en tu pipeline según tus necesidades
                }
            }
        }

        // Agrega más etapas según tus necesidades
    }
}



##############################################################################################
kind: BasicProject
apiVersion: v1
metadata:
  name: Nombre_de_proyecto
  files_8_3: True
spec:
  step1:
    componente1:
      - mx0001
      - mx0002
    componente2:
      - mx0001
      - mx0002
    componente3:
      - mx0001
  step2:
    componente4:
      - mx0001
      - mx0002
    componente5:
      - mx0001
      - mx0002
    componente6:
      - mx0001 


pipeline {
    agent any
    
    stages {
        stage('Read YAML') {
            steps {
                script {
                    def yamlContent = readYaml file: 'ruta/al/tu/archivo.yaml'
                    
                    yamlContent.spec.each { stepName, components ->
                        stage("Step ${stepName}") {
                            parallel components.collectEntries { componentName, mxList ->
                                ["${componentName}": {
                                    steps {
                                        mxList.each { mxValue ->
                                            script {
                                                // Aquí puedes ejecutar tus tareas para cada mxValue
                                                echo "Ejecutando ${componentName} con mx ${mxValue} en el paso ${stepName}"
                                                // Puedes agregar aquí tus comandos específicos de Jenkins
                                            }
                                        }
                                    }
                                }]
                            }
                        }
                    }
                }
            }
        }
    }
}





############################################################################################################3333

kapiVersion: v1
metadata:
  name: Nombre_de_proyecto
  files_8_3: True
spec:
  step1:
    - componente1
    - componente2
    - componente3
  step2:
    - componente4
    - componente5
    - componente6 


pipeline {
    agent any
    
    stages {
        stage('Read YAML') {
            steps {
                script {
                    def yamlContent = readYaml file: 'ruta/al/tu/archivo.yaml'
                    
                    yamlContent.spec.each { stepName, components ->
                        stage("Step ${stepName}") {
                            parallel components.collectEntries { componentName ->
                                ["${componentName}": {
                                    steps {
                                        // Aquí puedes ejecutar tus tareas para cada componente
                                        echo "Ejecutando ${componentName} en el paso ${stepName}"
                                        // Puedes agregar aquí tus comandos específicos de Jenkins
                                    }
                                }]
                            }
                        }
                    }
                }
            }
        }
    }
}


############################################################################################################3333


kapiVersion: v1
metadata:
  name: Nombre_de_proyecto
  files_8_3: True
spec:
  step1:
    - componente1
    - componente2
    - componente3
  step2:
    - componente4
    - componente5
    - componente6 


Y leyendo los recursos de otro sitio.


pipeline {
    agent any
    
    stages {
        stage('Read YAML') {
            steps {
                script {
                    def mxValues = ["mx0001", "mx0003"]
                    def yamlContent = readYaml file: 'ruta/al/tu/archivo.yaml'
                    
                    yamlContent.spec.each { stepName, components ->
                        stage("Step ${stepName}") {
                            parallel components.collectEntries { componentName ->
                                ["${componentName}": {
                                    steps {
                                        mxValues.each { mxValue ->
                                            echo "Ejecutando ${componentName} con mx ${mxValue} en el paso ${stepName}"
                                            // Puedes agregar aquí tus comandos específicos de Jenkins
                                        }
                                    }
                                }]
                            }
                        }
                    }
                }
            }
        }
    }
}


###################################################################################################33


def getResources(String component) {
    def config = readYaml file: component
    return config.spec.resources
}

def resources = ""

pipeline {
    agent any
    
    stages {
        stage('Deploy Release') {
            steps {
                script {

                    def releaseProcess = readYaml file: 'ruta/al/tu/archivo.yaml'
                    
                    releaseProcess.spec.each { stepName, components ->
                        stage("${stepName}") {
                            parallel components.collectEntries { componentName ->
                                ["${componentName}": {
                                    steps {

                                        resources = getResources("${componentName}")
                                        resources.each { resourceValue ->
                                            echo "Ejecutando ${componentName} con mx ${resourceValue} en el paso ${stepName}"
                                        }
                                    }
                                }]
                            }
                        }
                    }
                }
            }
        }
    }
}

###########################################################################################################333

def getResources(String component) {
    def config = readYaml file: component
    return config.spec.resources
}

def resources = ""

pipeline {
    agent any
    
    stages {
        stage('Deploy Release') {
            steps {
                script {
                    def releaseProcess = readYaml file: 'ruta/al/tu/archivo.yaml'
                    
                    releaseProcess.spec.each { stepName, components ->
                        stage("${stepName}") {
                            steps {
                                parallel components.collectEntries { componentName ->
                                    ["${componentName}": {
                                        script {
                                            resources = getResources("${componentName}")
                                            parallel resources.collectEntries { resourceValue ->
                                                ["${resourceValue}": {
                                                    echo "Ejecutando ${componentName} con mx ${resourceValue} en el paso ${stepName}"
                                                }]
                                            }
                                        }
                                    }]
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

##########################################################################################

Tengo un json en un fichero de este estilo:
{"versions":[{"componente1":"1.0.0"},{"componente2":"1.0.2"}]}
Quiero una funcion para un pipeline en el cual yo le pase el nombre del componente y me devuelva la version. Si no existe me devuelva None


def getComponentVersion(componente, release) {
    def jsonContent = readJSON file: release + "/descriptor.json"
    def versions = jsonContent.versions
    
    versions.each { version ->
        if (version.containsKey(componente)) {
            return version[componente]
        }
    }

    return null
}


def version = getComponentVersion(componente, RELEASE)
if (version != null) {
  echo "La versión de ${componente} es: ${version}"
} else {
  echo "El componente ${componente} no tiene una versión definida."
}

###########################################################################################################333

def getComponentVersion(String componente, String release) {
    def jsonContent = readJSON file: release + "/descriptor.json"
    def versions = jsonContent.versions
    
    versions.each { version ->
        if (version.containsKey(componente)) {
            return version[componente]
        }
    }

    return null
}


def getResources(String component) {
    def config = readYaml file: component + "yaml"
    return config.spec.resources
}


def getVersionIsDeploy(String component, String application, String release, String resource) {
    return False
}

def getOnlyChanges(String release) {
    return False
}

def nexusDownloaderRelease(String release) {
    return False
}

def resources = ""

pipeline {
    agent any
    
    stages {
        stage('Deploy Release') {
            steps {
                script {
                    // Leemos archivo yaml de proceso de despliegue de la aplicacion
                    def releaseProcess = readYaml file: 'configApplicationProcess.yaml' // configApplicationProcess
                    // comprobamos si aunque este desplegada la release tenemos que volver a desplegarla.
                    onlyChanges = getOnlyChanges(release)
                    // Leemos todos los steps del proceso e iteramos sobre ellos
                    releaseProcess.spec.each { stepName, components ->
                        stage("${stepName}") {
                            steps {
                                // Lanzamos en paralelo todos los componentes que tenga asociado el step
                                parallel components.collectEntries { componentName ->
                                    ["${componentName}": {
                                        script {
                                            // Comprobamos si el componente tiene vesion asociada en la release
                                            version = getComponentVersion(componente, RELEASE)
                                            if (version != null) {

                                              // como tiene version asociada leemos los recursos donde se desplegara el componente
                                              resources = getResources("${componentName}")
                                              parallel resources.collectEntries { resourceValue ->
                                                
                                                if (onlyChanges){
                                                  // comprobamos si esa version de esa release esta desplegada en ese recurso
                                                  def isDeployed = getVersionIsDeploy(componente, aplicacion, release, resource)
                                                }else{
                                                  isDeployed = True
                                                }
                                                if (isDeployed) {
                                                  // Ejecutamos el job de despliegue sobre ese recurso ya que no
                                                  // tiene esa version desplegada.
                                                  ["${resourceValue}": {
                                                      echo "Ejecutando job ${componentName} para recurso ${resourceValue} en el paso ${stepName}"
                                                  }]
                                                }else{
                                                  echo "la version ${version} del componente ${componentName} ya esta desplegada para el recurso ${resourceValue}"
                                                }

                                              }

                                            }else{
                                              echo "El componente ${componentName} no tiene version en la release ${params.RELEASE} para desplegar."
                                            }
                                        }
                                    }]
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

